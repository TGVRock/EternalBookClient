import{l as E,f as I,e as B,C as w,k as V,v as J,g as c,w as Q}from"./index-8529961b.js";import{b as Y,a as P}from"./account-2c35004b.js";import{i as W,g as ee}from"./mosaic-2acaed25.js";import{C as ne,k as te,b as oe,l as ae,m as O,f as re,h as ie,i as L,j as se}from"./eternalbookprotocol-1dc854f0.js";var h=(e=>(e.Undefined="Undefined",e.Fetching="Fetching",e.Complete="Complete",e.Failed="Failed",e))(h||{}),t=(e=>(e.Standby="Standby",e.Preprocess="Preprocess",e.LockAnnounced="LockAnnounced",e.LockSigning="LockSigning",e.LockUnconfirmed="LockUnconfirmed",e.LockConfirmed="LockConfirmed",e.TxSigning="TxSigning",e.TxAnnounced="TxAnnounced",e.TxWaitCosign="TxWaitCosign",e.TxUnconfirmed="TxUnconfirmed",e.TxConfirmed="TxConfirmed",e.Complete="Complete",e.Failed="Failed",e))(t||{});const f=E(),C=I();async function X(e,r,g,x,m,l,u){const s="open listener:";if(f.logger.debug(s,e,"start"),typeof C.namespaceRepo>"u"){f.logger.error(s,e,"repository undefined.");return}const a=new B.Listener(C.wsEndpoint,C.namespaceRepo,WebSocket);return await a.open().then(()=>{f.logger.debug(s,e,"listener opened."),a.newBlock(),a.status(r,g).subscribe(n=>{f.logger.error(s,e,"tx status:",n),typeof u<"u"&&u(),a.close()}),a.aggregateBondedAdded(r,g).subscribe(()=>{f.logger.debug(s,e,"tx aggregate bonded added"),typeof x<"u"&&x()}),a.unconfirmedAdded(r,g).subscribe(()=>{f.logger.debug(s,e,"tx unconfirmed added"),typeof m<"u"&&m()}),a.confirmed(r,g).subscribe(async()=>{f.logger.debug(s,e,"tx confirmed"),typeof l<"u"&&l(),a.close()})}).catch(n=>{f.logger.error(s,e,"failed.",n)}),f.logger.debug(s,e,"end"),a}const _=E(),K=I();async function de(){const e="get tx fees:";if(typeof K.networkRepo>"u"){_.logger.error(e,"repository undefined.");return}return await K.networkRepo.getTransactionFees().toPromise().then(r=>r).catch(r=>{_.logger.error(e,"failed.",r)})}async function k(e){const r="get tx fee:",g=await de();return typeof g>"u"?(_.logger.error(r,"get tx fees failed."),w.TX_FEE_MULTIPLIER_DEFAULT):ne(g,e)}const pe=V("WriteOnChainData",()=>{const e=E(),r=I(),g=J(),x=c(""),m=c(""),l=c(""),u=c(void 0),s=c(h.Undefined),a=c(""),n=c(t.Standby),d=c(0),F=c("");Q(l,()=>{const i="write data store watch:";if(e.logger.debug(i,"start",l.value),!W(l.value)){s.value=l.value.length===0?h.Undefined:h.Failed,u.value=void 0;return}ee(l.value).then(o=>{e.logger.debug(i,"get mosaic info complete.",o),u.value=o,s.value=h.Complete}).catch(o=>{e.logger.debug(i,"get account info failed.",o),u.value=void 0,s.value=h.Failed}),e.logger.debug(i,"end")},{immediate:!0});async function G(){const i="write data:";if(e.logger.debug(i,"start"),n.value!==t.Standby&&n.value!==t.Complete&&n.value!==t.Failed){e.logger.error(i,"other processing.");return}if(n.value=t.Preprocess,d.value=0,F.value="",a.value.length===0){e.logger.error(i,"data no setting."),n.value=t.Failed;return}if(typeof u.value>"u"){e.logger.error(i,"mosaic info undefined."),n.value=t.Failed;return}const o=await Y(u.value.ownerAddress.plain()),y=typeof o>"u"?!1:o.isMultisig();U(y),e.logger.debug(i,"end")}async function U(i){var H,N;const o="write data:";if(e.logger.debug(o,"start"),n.value=t.Preprocess,e.logger.debug(o,"processed size",d.value),d.value>=a.value.length){e.logger.debug(o,"all data proceeded."),n.value=t.Complete;return}const y=d.value+w.TX_DATASIZE_PER_TRANSFER*w.TX_DATA_TX_NUM>=a.value.length,p=u.value;if(typeof p>"u"){e.logger.error(o,"mosaic info undefined."),n.value=t.Failed;return}const S=await P(p.ownerAddress.plain());if(typeof S>"u"){e.logger.error(o,"account info invalid."),n.value=t.Failed;return}const q=te(p.id.toHex(),p.ownerAddress.plain(),x.value,m.value,d.value===0?void 0:F.value,y?oe(a.value):void 0),R=ae(q,p.id.toHex());if(typeof R>"u"){e.logger.error(o,"create crypto header failed."),n.value=t.Failed;return}const b=[],z=O(S,R);for(b.push(z.toAggregate(S.publicAccount));b.length<w.TX_AGGREGATE_INNER_NUM&&!(d.value>=a.value.length);){const T=a.value.substring(d.value,d.value+w.TX_DATASIZE_PER_TRANSFER),j=O(S,T);b.push(j.toAggregate(S.publicAccount)),d.value+=T.length}const M=i?re(b,await k(e.feeKind)):ie(b,await k(e.feeKind));if(!e.useSSS&&typeof e.account>"u"){e.logger.error(o,"account invalid."),n.value=t.Failed;return}n.value=t.TxSigning;const v=e.useSSS?await g.requestTxSign(M):(H=e.account)==null?void 0:H.sign(M,r.generationHash);if(typeof v>"u"){e.logger.error(o,"sss sign failed."),n.value=t.Failed;return}if(typeof await X("write data",p.ownerAddress,v.hash,()=>{n.value=t.TxWaitCosign},()=>{n.value=t.TxUnconfirmed},async()=>{d.value<a.value.length?(F.value=v.hash,U(i)):(F.value="",n.value=t.Complete)},()=>{n.value=t.Failed})>"u"){e.logger.error(o,"open create mosaic tx listener failed."),n.value=t.Failed;return}if(!i){n.value=t.TxAnnounced;const T=await L(v);e.logger.debug(o,"aggregate complete tx announced.",[v,T]),e.logger.debug(o,"aggregate complete end");return}const D=se(v,await k(e.feeKind));n.value=t.LockSigning;const A=e.useSSS?await g.requestTxSign(D):(N=e.account)==null?void 0:N.sign(D,r.generationHash);if(typeof A>"u"){e.logger.error(o,"sss sign failed."),n.value=t.Failed;return}const Z=B.Address.createFromPublicKey(A.signerPublicKey,r.networkType);if(typeof await X("hash lock",Z,A.hash,void 0,()=>{n.value=t.LockUnconfirmed},async()=>{n.value=t.TxAnnounced;const T=await L(v);e.logger.debug(o,"aggregate bonded tx announced.",[v,T])},()=>{n.value=t.Failed})>"u"){e.logger.error(o,"open hash lock tx listener failed."),n.value=t.Failed;return}n.value=t.LockAnnounced;const $=await L(A);e.logger.debug(o,"hashlock tx announced.",[A,$]),e.logger.debug(o,"aggregate bonded end")}return{title:x,message:m,relatedMosaicIdStr:l,dataBase64:a,progress:n,processedSize:d,writeOnChain:G}});export{t as W,k as a,de as g,X as o,pe as u};
